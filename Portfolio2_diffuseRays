package portfolio;

import java.awt.Color;
import java.awt.Font;
import java.awt.Frame;
import java.awt.Graphics;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.util.Scanner;

public class Portfolio2_diffuseRays extends Frame implements Runnable
{
	static String flowStr = null;										//矢印の指定方向（インプット用）
	static String flowStrFull = null;									//矢印の指定方向（データベース登録用）
	static int flowInt = -1;										//矢印の指定方向（制御用）
	static int speed = 0;											//矢印のスピード
	static int reflector = 0;										//反射板のサイズ
	static String result = null;										//集計結果
	boolean finish = false;											//集計結果をウィンドウに表示するスイッチ
	
	double[][]positionX = new double[30][17];								//矢印の位置（X座標）
	double[][]positionY = new double[30][17];								//矢印の位置（Y座標）
	int[][]direction = new int[30][17];									//矢印の現在方向
	String[][] str = new String[30][17];									//矢印の現在方向による形状
	
	public static void main(String[] args) 
	{
		Scanner scanner = new Scanner(System.in);
		System.out.println("方向を入力して下さい。\n上：「u」\n左：「l」\n右：「r」\n下：「d」");
		while(flowInt<0 || flowInt>360) {
			flowStr = scanner.next();								//矢印の初期方向をインプット
			if(flowStr.equals("r")==true) {
				flowInt = 0;
				flowStrFull = "right";
			}else if(flowStr.equals("d")==true) {
				flowInt = 90;
				flowStrFull = "down";
			}else if(flowStr.equals("l")==true) {
				flowInt = 180;
				flowStrFull = "left";
			}else if(flowStr.equals("u")==true) {
				flowInt = 270;
				flowStrFull = "up";
			}else {
				System.out.println("方向の指定が誤っています。もう一度入力してください"
						+ "\n（半角で入力する必要があります）。");
			}
		}
		System.out.println("スピードを入力して下さい。\n（整数1～10）");
		speed = scanner.nextInt();									//矢印のスピードをインプット
		System.out.println("反射板の大きさを入力してください。\n（整数0～300）");
		reflector = scanner.nextInt();									//反射板の大きさをインプット
		scanner.close();										//システムリソースの解放
		@SuppressWarnings("unused")
		Portfolio2_diffuseRays sm = new Portfolio2_diffuseRays();					//直後のメソッドでインスタンスを宣言・生成
	}
	
	public Portfolio2_diffuseRays() {
		super("ポートフォリオ用");
		if(flowInt == 0) {										//矢印の指定方向が0（右）の場合の矢印の初期位置・方向を設定
			for(int k=0; k<30; k++) {
				for(int m=0; m<17; m++) {
					positionX[k][m] = 50;
					positionY[k][m] = 225;
					direction[k][m] = 315+5+5*m;
				}
			}
		}else if (flowInt == 90) {									//矢印の指定方向が90（下）の場合の矢印の初期位置・方向を設定
			for(int k=0; k<30; k++) {
				for(int m=0; m<17; m++) {
					positionX[k][m] = 375;
					positionY[k][m] = 100;
					direction[k][m] = 45+5+5*m;
				}
			}
		}else if (flowInt == 180) {									//矢印の指定方向が180（左）の場合の矢印の初期位置・方向を設定
			for(int k=0; k<30; k++) {
				for(int m=0; m<17; m++) {
					positionX[k][m] = 550;
					positionY[k][m] = 225;
					direction[k][m] = 135+5+5*m;
				}
			}
		}else if (flowInt == 270) {									//矢印の指定方向が270（上）の場合の矢印の初期位置・方向を設定
			for(int k=0; k<30; k++) {
				for(int m=0; m<17; m++) {
					positionX[k][m] = 375;
					positionY[k][m] = 360;
					direction[k][m] = 225+5+5*m;
				}
			}	
		}
		addWindowListener(new SampleWindowListener());							//ウィンドウを生成
		Thread th;											//Threadクラスでthスレッドを宣言
		th = new Thread(this);										//同一クラス内にあるため、引数thisでインスタンス生成
		th.start();											//Threadクラス内のstartメソッドの呼び出し
		setAlwaysOnTop(true); 										//ウィンドウを最前面に移動
		setSize(700, 400);										//ウィンドウのサイズを設定
		setVisible(true);										//ウィンドウを表示
		
		try {
		th.join();											//スレッドの終了を待機
		}catch(InterruptedException e) {
		}
		System.out.println("集計します。");	
		int rightQuantity=0;										//スレッド終了時の右方向の矢印の数
		int upQuantity=0;										//スレッド終了時の上方向の矢印の数
		int leftQuantity=0;										//スレッド終了時の左方向の矢印の数
		int downQuantity=0;										//スレッド終了時の下方向の矢印の数
		for(int k=0; k<30; k++) {
			for(int m=0; m<17; m++) {
				if(direction[k][m]%360>=45 && direction[k][m]%360<135) {			//スレッド終了時の下方向の矢印の数をカウント
					downQuantity++;
				}else if(direction[k][m]%360>=-315 && direction[k][m]%360<-225) {		//スレッド終了時の下方向の矢印の数をカウント
					downQuantity++;
				}else if(direction[k][m]%360>=135 && direction[k][m]%360<225){			//スレッド終了時の左方向の矢印の数をカウント
					leftQuantity++;
				}else if(direction[k][m]%360>=-225 && direction[k][m]%360<-135){		//スレッド終了時の左方向の矢印の数をカウント
					leftQuantity++;
				}else if(direction[k][m]%360>=225 && direction[k][m]%360<315) {			//スレッド終了時の上方向の矢印の数をカウント
					upQuantity++;
				}else if(direction[k][m]%360>=-135 && direction[k][m]%360<-45) {		//スレッド終了時の上方向の矢印の数をカウント
					upQuantity++;
				}else if(direction[k][m]%360>=315 || direction[k][m]%360<45){			//スレッド終了時の右方向の矢印の数をカウント
					rightQuantity++;
				}else if(direction[k][m]%360>=-45 || direction[k][m]%360<-315){			//スレッド終了時の右方向の矢印の数をカウント
					rightQuantity++;
				}
			}
		}
		result = "上方向は"+upQuantity+"個、\n左方向は"+leftQuantity+"個、\n右方向は"
		+rightQuantity+"個、\n下方向は"+downQuantity+"個です。";						//集計結果（矢印の数）を文章化
		finish = true;											//集計結果をウィンドウに表示するスイッチをオン
		System.out.println(result);									//集計結果（矢印の数）をコンソールに表示
		ConnectMariaDB.connectMariaDB(flowStrFull,reflector,leftQuantity,
				upQuantity,downQuantity,rightQuantity);						//集計結果をデータベースに入力
	}
	
	public void run() {
		try{
			int time=0;										//シミュレート開始からの経過時間
			while(time<1800) {	
				for(int k=0; k<30; k++) {
					if(time>=k*40){					//時間が40カウントされるごとに次の17個の矢印がスタート（これを30回繰り返す）
						for(int m=0; m<17; m++) {
							if(Math.abs(positionY[k][m]-230 - (1*(positionX[k][m]-330))) < 1
								&& positionY[k][m]>=230-reflector/2
								&& positionY[k][m]<=230){
								direction[k][m]=45*2-direction[k][m];
							}else if(Math.abs(positionY[k][m]-230 - (-1*(positionX[k][m]-330))) < 1
								&& positionY[k][m]<=230+reflector/2
								&& positionY[k][m]>=230	) {
								direction[k][m]=315*2-direction[k][m];
							}
							positionX[k][m]+=Math.cos(Math.toRadians(direction[k][m]));
							positionY[k][m]+=Math.sin(Math.toRadians(direction[k][m]));
						}
					}
				}
				repaint();									//paintメソッドの呼び出し（経過時間ごとに矢印の描画を実行）
				Thread.sleep(100/speed);							//（100/speed）ミリ秒待機
				time++;
			}
			repaint();										//paintメソッドの呼び出し（スレッド終了時、集計結果の描画を実行）
		}catch(InterruptedException e) {}
	}
	
	public void paint(Graphics g) 
	{
		for(int k=0; k<30; k++) {									//多次元配列strに矢印の形状を代入
			for(int m=0; m<17; m++) {
				if(direction[k][m]%360>=45 && direction[k][m]%360<135) {
					str[k][m] = "↓" ;
				}else if(direction[k][m]%360>=-315 && direction[k][m]%360<-225) {
					str[k][m] = "↓" ;
				}else if(direction[k][m]%360>=135 && direction[k][m]%360<225) {
					str[k][m] = "←" ;
				}else if(direction[k][m]%360>=-225 && direction[k][m]%360<-135) {
					str[k][m] = "←" ;
				}else if(direction[k][m]%360>=225 && direction[k][m]%360<315)  {
					str[k][m] = "↑" ;
				}else if(direction[k][m]%360>=-135 && direction[k][m]%360<-45)  {
					str[k][m] = "↑" ;
				}else if(direction[k][m]%360>=315 || direction[k][m]%360<45) {
					str[k][m] = "→" ;
				}else if(direction[k][m]%360>=-45 || direction[k][m]%360<-315) {
					str[k][m] = "→" ;
				}
				
				
			}
		}
		g.setColor(Color.GREEN);
		g.fillRect(0, 0, 700, 400);
		g.setColor(Color.RED);
		Font font = new Font("MS Gothic", Font.ROMAN_BASELINE, 12);
		g.setFont(font);
		for(int i=0; i<reflector-20; i+=5) {								//反射板の描画
			g.drawString("＼", 325-i/2, 225-i/2);
			g.drawString("／", 325-i/2, 235+i/2);
			}
		g.setColor(Color.BLUE);
		for(int k=0; k<30; k++) {
			for(int m=0; m<17; m++) {
				g.drawString(str[k][m], (int)positionX[k][m], (int)positionY[k][m]);		//矢印の描画
			}
		}
		if(finish == true) {										//スレッド終了時、集計結果の描画を実行
			Font fg = new Font("SansSerif" , Font.PLAIN , 20);
			g.setFont(fg);
			g.setColor(Color.BLACK);
			g.drawString("集計します。",55,70);
			g.drawString(result,55,100);
		}
	}
	
	class SampleWindowListener extends WindowAdapter{
		public void windowClosing(WindowEvent e){
			System.exit(0);
		}
	}
}
